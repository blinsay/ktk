package main

import (
	"bufio"
	"io"
)

// An interface for chaining together multiple Scanners. Calls to Scan step
// through the tokens of each underlying io.Reader in order. There is no
// delineation between the chained readers and no indication which file
// a token comes from.
type MultiScanner struct {
	supplier ReaderSupplier
	err      error
	scanner  *bufio.Scanner
}

// NewMultiScanner returns a MultiScanner that reads from the supplied
// readers in order.
func NewMultiScanner(rs ReaderSupplier) *MultiScanner {
	return &MultiScanner{
		supplier: rs,
	}
}

// Advance the scanner to the next token, possibly in the next file. Returns
// false when the scan stops due to an error or to reaching the end of all
// of the supplied data.
func (m *MultiScanner) Scan() bool {
	for {
		if m.scanner == nil {
			r, err := m.supplier.Reader()
			// If there's an error getting the next io.Reader, be done.
			if err != nil {
				m.err = err
				return false
			}

			// If there's no new io.Reader to consume, be done.
			if r == nil {
				m.err = io.EOF
				return false
			}

			m.scanner = bufio.NewScanner(r)
		}

		if !m.scanner.Scan() {
			// Save the error encountered and return.
			if err := m.scanner.Err(); err != nil {
				m.err = err
				return false
			}

			// EOF was reached. Loop and grab the next io.Reader to scan.
			m.scanner = nil
			continue
		}
		return true
	}
}

// Returns the last error this scanner encountered.
func (m *MultiScanner) Err() error {
	if m.err == io.EOF {
		return nil
	}
	return m.err
}

// Return the most recent token generated by a call to Scan.
func (m *MultiScanner) Bytes() []byte {
	return m.scanner.Bytes()
}

// Return the most recent token generated by a call to Scan as a newly allocated
// string.
func (m *MultiScanner) Text() string {
	return m.scanner.Text()
}
